\chapter{Závěr}

Cílem této práce bylo ověřit předpoklad, že implementace \MIndex{u} v~jazyce \CC{} bude rychlejší než implementace v~jazycích Java a C\#.
Toto se potvrdilo, i když nebylo k~dispozici původní prostředí, v~kterém měřili kolegové Kmuníček a Koman a bylo nutné portovat původní zdrojové kódy \CC{} z~Windows na Linux.
Implementace v~Java je pomalejší než v~\CC, ale je rychlejší než v~C\#.

Jazyk \CC{} umožňuje mít správu paměť pod větší kontrolou než Java, ale vyžaduje také větší disciplínu od programátora.
Při nedodržení všech pravidel pro práci s~uvolňováním, dochází k~únikům paměti.
Příkladem byla statická analýza provedená na implementaci v~\CC{}.

Z~uskutečněných měření vyplynulo, že \MIndex{} není závislý jen parametrech, jako je počet pivotů rozdělujících množinu objektů a jeho maximální úroveň dělení, ale také na parametrech použitých pomocných struktur.
V~tomto případě na stupni \BPTree.
Měření proběhlo více jak 5000, což je už dostatečný reprezentační vzorek pro podložení závěrů této práce.

\MIndex{} nebyl zkoumán na průběh ořezávání clusterů, ale větší důraz byl kladen na praktičnost implementace a na parametry JVM, které ovlivňují výkonnost programu běžícím v~JVM.
Z~těchto měření lze doporučit nevypínat volbu \cmd{-XX:+UseCompressedOops} v~64 bitové JVM neboť má zásadní význam na celkový výkon aplikace.
Volbu \cmd{-XX:+AggressiveOpts} lze doporučit zapínat, ovšem s~tím, že její dopad na výkon se může lišit s~verzemi JVM a je tedy nutné si ověřit (změřit) výkon s~každou novou verzí JVM.
V~práci byly také popsány úskalí spojené se správným měřením výkonnosti v~JVM -- interpretovaný kód, dynamický překlad \bytecode{} za běhu aplikace, možné optimalizace výsledného kódu kompilátorem, zavádění tříd a automatický úklid paměti v~Java.
Byl uveden i návod na minimalizování ovlivnění měření \uv{zahřátím} JVM.

Další možný směr výzkumu \MIndex{u} lze vidět v:
\begin{itemize}
\item Paralelní implementaci \emph{Range Query}, která by se dala uplatnit u~velmi velkých množin objektů v~metrickém prostoru a využít potenciál dnešních více-jádrových a více-vláknových procesorů. V~této implementaci se již paralelismus využívá při výpočtu maximální vzdálenosti v~množině prvků mezi sebou a při výpočtu vzdáleností objektů k~pivotům \MIndex{u}.
\item Zaměření na využití vektorových instrukcí procesorů při řešení prokletí dimensionality, i když zde je zřejmě nemožné využít jazyk Java, protože nemá zabudovanou podporu pro vektorové instrukce.
\item Jakým způsobem ovlivňují velikosti struktur výpadky CPU cache a popsat způsob pro určení optimálních velikostí.
\item Implementovat distribuovanou hašovací mapu místo \BPTree{}, která by měla obdobně jako paralelní výpočty uplatnění při vyhledávání ve velmi velkých množinách objektů.
\item Implementace vyhledání nejbližších $n$-prvků k~danému bodu
 \end{itemize}
 
Při vypracovávání této práce jsem využil všech znalostí a zkušeností nabytých nejen během studia na VŠFS, ale také zkušeností z~předchozího nedokončeného studia na ČVUT a z~praxe.
Tyto znalosti a zkušenosti mi dovolují zapochybovat nad praktickým uplatněním mé implementace \MIndex{u}.
Důvodem je nutnost spočítání maximální vzdálenosti mezi objekty pro vyhledávání na začátku.
Použitý naivní způsob výpočtu maximální vzdálenosti mezi prvky v~množině má složitost \BigO{n^2}.
Pro velké množiny objektů v~řádu miliónů, resp. při přidání objektu do této množiny, je nutné znovu spočítat maximální vzdálenost a většinu času by zabral tento výpočet i pokud by byl paralelní.
Efektivnější způsob vyhledání maximální vzdálenosti je za použití \emph{konvexního obalu}, který je popsán v \cite{Cormen:2001:IA:580470}.
\footnote{V anj. \emph{convex hull}.}
Tento algoritmus má již složitost \BigO{n \log{n}}.
Dále by bylo nutné upravit \MIndex{} tak, aby se přepočítala maximální vzdálenost při vložení nového objektu.
Pokud by byla nalezená maximální vzdálenost větší než současná, \MIndex{} by znovu vytvořil svoji strukturu.