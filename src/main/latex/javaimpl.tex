\chapter{\MIndex{} implementace v~jazyce Java}


\section{Jazyk Java, JVM}

Jazyk Java je silně typovaný jazyk. Tento jazyk není interpretovaný,
výsledkem překladu je \bytecode{}.\footnote{\bytecode{} jsou instrukce pro JVM. Více viz. \prettyref{sub:JIT}} Až tento \bytecode{} je interpretován v~tzv. Java Virtual Machine (JVM\nomenclature{JVM}{Java Virtual Machine}).
Díky JVM může kód přeložený na jedné platformě (ať už Windows nebo Unix a 32bit nebo 64bit) běžet na jiné. \footnote{\emph{\uv{Write once, run anywhere}}\cite{lindholm2013java}}

Hlavní klíčové vlastnosti, jak jazyka Java, JVM a JDK\nomenclature{JDK}{Java Development Kit}
jsou tyto: automatická alokace a dealokace paměti, objektovost, generika,
překlad \bytecode{} do nativních instrukcí procesoru, bohatá
knihovna tříd v~základním JDK\ldots{}

\subsection{Automatická správa paměti -- garbage collection}

V~jazyce Java neexistují ukazatele, pouze reference. V~jazycích C/\CC{}
se musí vývojář starat o~správu paměti pomocí funkcí \method{malloc},
\method{free} (jazyk C a \CC), resp. operátorů \method{new} a \method{delete}
(jazyk \CC). V~jazyce Java, resp. v~JVM \cite{lindholm2013java} tuto starost přebírá tzv. \emph{garbage
collector} (GC\nomenclature{GC}{garbage collector}), který sleduje
dosažitelnost alokovaných objektů v~paměti JVM. Pokud GC
zjistí, že objekt není dosažitelný z~jiných objektů, uvolní pamět daného objektu.
\footnote{Podobná technika/pattern je součástí \CC 11 pomocí \type{std::shared\_ptr},
kde se používá \emph{reference counting} \cite{ISO:2012:CPP}. Tato technika není použitelná v~případě cyklických referencí. Při výskytu cyklických referencí by se měl použít i \type{std::weak\_ptr}.
}

Díky automatické správě paměti je vývoj výrazně rychlejší.
Automatická správa paměti ovšem neznamená, že program je chráněn proti všem únikům paměti.\footnote{V anj. \emph{memory leaks}.}
Pokud se např. \uv{opomene} odstranit záznam z mapy, odkazovaná instance nikdy nebude uvažována pro GC a vznikne únik paměti.

\subsubsection{Jak funguje GC}
Ve většině JVM se používá generační GC, který vychází ze dvou vypozorovaných chování:
\begin{itemize}
  \item Většina alokovaných objektů je velmi brzy nepotřebná, tzn. nejsou na ně žádná reference
  \item Jen několik starších objektů odkazuje na mladší objekty
\end{itemize}
Tyto dvě pozorování jsou známy jako \emph{slabá generační hypotéza}\cite{hunt2011java},\footnote{V anj. \emph{weak generational hypothesis}.} která platí pro většinu programů v Java.
K využití této hypotézy je v JVM rozdělena \emph{halda}\footnote{V anj. \emph{heap}} na dvě fyzické části, které jsou odkazované jako generace:

\missingfigure{Jak vypada alokace a promovani}
\begin{description}
  \item[Mladá generace] Většina objektů je alokována do této oblasti, která je relativně malá a je často \uv{uklízena}.
Jelikož je předpoklad, že objekty jsou velmi rychle nepotřebné, jen velmi málo objektů \uv{přežije} úklid v této oblasti.
Obecně je úklid v této oblasti velmi efektivní, protože je prováděn v malé oblasti paměti, která obsahuje hodně odpadních objektů.

  \item[Stará generace] Objekty, které \uv{žijí} déle, jsou promovány do této oblasti.
Tato oblast je výrazně větší než \emph{mladá generace} a její obsazování probíhá pomalu.
Úklid v této oblasti (nazývaný \emph{full GC}) není častý, ale pokud už k němu dojde, může být velmi dlouhý.

  \item[Permanentní generace] Toto je třetí oblastí generací, ale není použita v generační hierarchii.
JVM ji používá pro ukládání metadat jako jsou informace o třídách, internovaných řetězců atd\ldots
\end{description}

\subsubsection{Typy GC\label{subsub:gctypes}}

V Oracle JVM je k dispozici několik GC. Liší se způsobem provádění úklidu a kdy dochází k tzv. \emph{zastavení světa}.\footnote{V anj. \emph{stop the world}}
\emph{Zastavení světa} znamená, že všechna vlákna programu jsou pozastavena a pouze vlákna pro úklid jsou v činnosti.
Je to z důvodu toho, aby nedocházelo k novým alokacím objektů.
Samozřejmě, že toto má negativní dopad na aplikaci, pokud k zastavení dochází často.

\prettyref{tab:gcs} obsahuje porovnání GC. Tabulka vyjadřuje, jakým způsobem probíhá úklid paměti jednotlivých generací.

\begin{table}
\center
\begin{tabular}{|l || l | l | p{2cm} | p{2cm} |}
\hline
& Serial GC & Parallel GC & CMS GC & G1 GC \\ \hline \hline
Paralelismus & Ne & Ano & Ano & Ano \\ \hline
Souběžnost & Ne & Ne & Ano & Ano \\ \hline
Úklid mladé gen. & Sériově & Paralelně & Paralelně & Paralelně \\ \hline
Úklid staré gen. & Sériově & Paralelně & Paralelně \& \mbox{Souběžně} & Paralelně \& \mbox{Souběžně} \\
 \hline
\end{tabular}
\caption{Porovnání GC\label{tab:gcs}}
\end{table}

\subsection{Generika\label{sub:generika}}

Obdobně jako v~\CC{} jsou \emph{templates}\cite{ISO:2012:CPP}, jazyk Java má \emph{generics}.\footnote{Uvedeny ve verzi 1.5 \cite{gosling2013java}.}
Jsou zde rozdíly:
\begin{itemize}
  \item v~Java se informace o~typu ztrácí během překladu. Překladač nahrazuje výskyt generika za konkrétní typ (třída, rozhraní)
  \item nelze jako typový parametr použít primitivní typ -- \type{int, char, byte, long, double, float} \ldots{}
  \item nelze použít netypový parametr
\end{itemize}

Zřejmě největším přínosem je typová bezpečnost při práci s~kolekcemi a možnosti typové specializace.

\subsection{Překlad \bytecode{} do nativních instrukcí procesoru}

JVM je heap procesor. Kvůli emulaci a virtualizaci procesoru je
běh samotného \bytecode{} relativně pomalý. JVM proto překládá
za běhu \bytecode{} do nativních instrukcí procesoru, nad kterým
aktuálně JVM běží. V~JVM od Oracle
 se nazývá JIT\nomenclature{JIT}{Just In Time} Compiler\cite{hunt2011java}. Samozřejmostí je optimalizace při několika průchodech
kódem -- např. \emph{function inlining}, \emph{loop unrolling} nebo \emph{dead code elimination}\cite{hunt2011java}. Toto jsou velmi důležité vlastnosti, které mohou zásadním způsobem
ovlivnit měření výkonnosti programu. Více viz.~\prettyref{sec:vykonvjava}.

\subsection{Bohatá knihovna tříd v~základním JDK}

Java je dodávána s~rozsáhlou knihovnou JDK. Obsahuje vše nutné
pro síťovou komunikaci (RPC\nomenclature{RPC}{Remote Procedure Call}), práci s~textem -- regulární výrazy,
XML, soubory a souborový
systém a také velmi propracovanou knihovnou kontejnerů -- \emph{Java
Collections Framework }(JFC\nomenclature{JFC}{Java Collections Framework})
\footnote{V~jazyce Java se používá pro termín \emph{container} (\CC) termín
\emph{collection}}.

\section{Návrh a implementace}
Implementace \MIndex u je napsána pro verzi Java 7.
V~celém návrhu jsem se snažil co nejvíce používat objektově orientovaný princip.
Tzn. že jsem se maximálně snažil omezit používaní nižších konstrukcí jazyka Java jako jsou pole a spíše využívat knihovny JDK a vyšších konstrukcí jako jsou seznamy, fronty.
Všechny implementované třídy a rozhraní jsou typově parametrizované viz. \prettyref{sub:generika}.

Při některých výpočtech bylo možné použít \emph{rozděl a panuj}\cite{Cormen:2001:IA:580470}\footnote{V anj. \emph{Divide-and-Conquer}} s~využitím \emph{Executor Framework} z~JDK.

V~popisovaných algoritmech (ať už \BPTree{} nebo \MIndex) je často uváděna proměnná \type{leaf}, resp. zda je daná struktura list -- koncový uzel.
Z~hlediska objektového návrhu se mění chování třídy podle její datové složky, což nesvědčí o~dobrém objektovém návrhu.
K~odstranění tohoto jsem použil \emph{Replace Type Code with Subclasses}\cite{fowler1999refactoring} pro \BPTree.
V~případě \MIndex{} \emph{Range Query} jsem použil \emph{Visitor pattern}\cite{gamma1995design}.

\subsection{\BPTree}
Implementace \BPTree{} se nachází v~třídě \linebreak \type{cz.rank.vsfs.btree.BPlusTreeMultiMap}. Tato mapa je typově parametrizována pro klíč a hodnotu. Protože strom musí být setříděný, musí klíč implementovat rozhraní \type{java.lang.Comparable}. Mapa umožňuje ukládat více objektů pod stejným klíčem\footnote{V \CC{} je obdobný kontejner \type{std::multimap}\cite{ISO:2012:CPP}. V~JDK žádná takováto kolekce není.} a umožňuje vyhledání v~intervalu.

Implementace mazání objektů z~mapy není potřebná pro \MIndex{} a není tudíž ani implementována.

Celý \BPTree{} je uložen v~hlavní paměti a není tedy implementováno načítaní a ukládání uzlů na disk.

\subsection{\MIndex}
Celá implementace \MIndex{} pracuje s~objekty, které implementují rozhraní \type{cz.rank.vsfs.mindex.Distanceable}. Tím je zajištěna případná znovupoužitelnost kódu pro jiné datové typy než je vektor.

\subsubsection{Výpočet maximální vzdálenosti mezi prvky}
Výpočet maximální vzdálenosti je NP problém, kdy se musí spočítat vzájemné vzdálenosti všech prvků v~množině a vybrat tu vzdálenost, která je největší. K~výpočtu lze použít \emph{rozděl a panuj}, takže je celý výpočet paralelní a doba výpočtu se lineárně snižuje s~počtem výpočetních vláken.

Funkcionalita je implementována ve třídě \type{cz.rank.vsfs.mindex.MaximumDistance}. Vzdálenost může být spočítána pouze nad objekty, které implementují rozhraní \type{Distanceable}.


\subsubsection{Výpočet vzdáleností mezi pivoty a prvky}
K~výpočtu a seřazení vzdáleností pivotů od objektu slouží třídy implementující rozhraní \type{cz.rank.vsfs.mindex.PivotDistanceTable}. Implementovány jsou tři třídy s~tímto rozhraním.

\begin{figure}
\centering
\begin{mpost}[use,mpsettings={input metauml;}]

Interface.A("PivotDistanceTable")
	("+calculate()",
	 "+pivotAt(object:D, index:int):Pivot<D>",
	 "+firstPivotDistance(object:D):double",
	 "+distanceAt(object:D, index:int):double",
	 "+pivotDistance(object:D, pivotIndex:int):double",
);

ClassTemplate.TA("Distanceable<D>")(A);

AbstractClass.B("AbstractPivotDistanceTable")
	()();
ClassTemplate.TB("Distanceable<D>")(B);
Class.C("ParallelPivotDistanceTable")
	()();
ClassTemplate.TC("Distanceable<D>")(C);

Class.D("SimplePivotDistanceTable")
	()();
ClassTemplate.TD("Distanceable<D>")(D);

Group.g(C,D);

topToBottom.midx(30)(A,B,g);
leftToRight(80)(C,D);

drawObjects(A, B, g, TA, TB, TC, TD);
clink(realization)(B,A);
link(inheritance)(pathStepY(C.n,B.s,10));
link(inheritance)(pathStepY(D.n,B.s,10));

\end{mpost}

\caption{\type{PivotDistanceTable} UML diagram}
\end{figure}

\begin{description}
\item[ParallelPivotDistanceTable] Rozdělí úlohu na menší části podle objektů pomocí \emph{rozděl a panuj} a výpočet je paralelizován za použití všech dostupných jader systému. Tato třída je využita při konstrukci samotného \MIndex.
\item[SimplePivotDistanceTable] Podobně jako \type{ParallelPivotDistanceTable} vypočte vzdálenosti objektu od pivotů, ale pouze pro jeden objekt a výpočet není paralelní. Tato třída se používá v~samotném \emph{Range Query} dotazu. Pokud by se použil \type{ParallelPivotDistanceTable}, tak režije spojená s~vytvářením úloh pro exekutory, vytvořením vláken, by byla výrazně vyšší než samotný výpočet vzdáleností jednoho objektu.
\item[AbstractPivotDistanceTable] Je společným předkem obou výše uvedených tříd a obsahuje společný kód, který potomci využívají.
\end{description}

\subsubsection{Cluster tree}
\begin{figure}
\centering
\begin{mpost}[use,mpsettings={input metauml;}]

Interface.Cluster("Cluster")
	("+getIndex():Index",
	 "+accept(visitor:ClusterVisitor<D>)",
	 "+getLevel():int",
	 "+getSubCluster(pivot:Pivot<D>):Cluster<D>",
);

ClassTemplate.TCluster("Distanceable<D>")(Cluster);

Class.InternalCluster("InternalCluster")
	()();
ClassTemplate.TInternalCluster("Distanceable<D>")(InternalCluster);
Class.RootCluster("RootCluster")
	()();
ClassTemplate.TRootCluster("Distanceable<D>")(RootCluster);

Class.LeafCluster("LeafCluster")
	()();
ClassTemplate.TLeafCluster("Distanceable<D>")(LeafCluster);

Group.g(RootCluster,LeafCluster);

topToBottom.midx(30)(Cluster,InternalCluster,g);
leftToRight(80)(RootCluster,LeafCluster);

drawObjects(Cluster, InternalCluster, g, TCluster, TInternalCluster, TRootCluster, TLeafCluster);
clink(realization)(InternalCluster,Cluster);
link(inheritance)(pathStepY(RootCluster.n,InternalCluster.s,10));
link(inheritance)(pathStepY(LeafCluster.n,InternalCluster.s,10));

\end{mpost}

\caption{\type{Cluster} UML diagram}
\end{figure}

Cluster tree je tvořen třídami, které implementuji rozhraní \linebreak \type{cz.rank.vsfs.mindex.Cluster}. Jsou celkem 3 -- 
\type{InternalCluster} a jeho potomci  \type{LeafCluster} a \type{RootCluster}.

\begin{description}
\item[InternalCluster] Je použit jako vnitřní cluster. Obsahuje všechnu funkcionalitu pro udržení informací o~podstromech, objektech, informace o~minimální a maximální vzdálenosti uložené v~clusteru.
\item[LeafCluster] Reprezentuje koncový cluster. Jeho metoda \linebreak \method{LeafCluster.getSubCluster} vrací vždy konstantu \type{NO\_SUBCLUSTERS}. Toto slouží k~identifikaci koncového clusteru při utváření dynamického \MIndex u.
\item[RootCluster] Je použit pro kořen celého clusteru, protože vyžaduje speciální zacházení s~indexem a také při akceptování \type{ClusterVisitor}.
\end{description}

Pro změření rozdílu použití více-stupňového \MIndex u a \MIndex u s~dynamickými stupni jsou implementovány dvě třídy -- \linebreak \type{cz.rank.vsfs.mindex.MultiLevelClusterTreeBuilder} a \linebreak \type{cz.rank.vsfs.mindex.DynamicClusterTreeBuilder}. Tyto třídy jsou použity v~\type{cz.rank.vsfs.mindex.MultiLevelMIndex}, \linebreak resp. \type{cz.rank.vsfs.mindex.DynamicMIndex} ke konstrukci specifického \MIndex u.
Obě třídy mají téměř totožný konstruktor, pouze u~\type{DynamicClusterTreeBuilder} je navíc parametr pro maximální zaplnění koncového clusteru. Více viz \prettyref{sec:Dynamic-Cluster-Tree}.

\subsubsection{Range Query}
Díky nezávislosti dotazu na typu clusteru (více-stupňový vs. s dynamickými stupni) je \emph{Range Query} je implementována v třídě \type{MIndex}, která je společný rodič pro \type{MultiLevelMIndex} a \type{DynamicMIndex}. V metodě rangeQuery není celá logika vyhledávání. V této metodě se inicializuje ClusterRangeQuery, která implementuje samotné vyhledávání. Toto řešení jsem zvolil kvůli oddělení zodpovědnosti vyhledávání a uchovávání informací o \MIndex u.\footnote{Jedná se o tzv. \emph{Single Responsibility Principle\nomenclature{SRO}{Single Responsibility Principle}}\cite{martin2003agile}}

V podstatě je téměř doslovně přepsán algoritmus popsaný v \prettyref{sec:Range-Query}. Jak bylo již zmíněno v začátku této sekce, k odstranění nutnosti identifikování typu clusteru za běhu\footnote{V jazyce Java k identifikaci typu slouží operátor \method{instanceof}\cite{gosling2013java}, obdobně jako v \CC{} je operátor \method{typeid}\cite{ISO:2012:CPP}} je použit \emph{Visitor Pattern}. \prettyref{fig:rangequery-visitor-seq} popisuje toto volání detailně.


%\begin{figure}
%\centering
%\begin{sequencediagram}
%  \newthread{mi}{:MIndex}{MIndex}
%  \newinst{rq}{:ClusterRangeQuery}{}
%  \newinst{ic}{:InternalCluster}{}
%  \newinst{lc}{:LeafCluster}{}
%
%  \begin{call}{mi}{performQuery()}{rq}{nalezené objekty}
%    \begin{sdblock}{Dotaz}{dokud není fronta clusterů prázdná}
%    \end{sdblock}
%  \end{call}
%\end{sequencediagram}
%
%\caption{Sekvenční diagram volání \emph{Range Query}}\label{fig:rangequery-visitor-seq}
%\end{figure}
\missingfigure{Sekvenční volání RangeQuery}

\section{Měření výkonu v~Java\label{sec:vykonvjava}}

Abychom porozuměli úskalí měření výkonu kódu v~JVM, je nejprve nutné si přiblížit, co se děje uvnitř JVM, jak probíhá překlad a optimalizace kódu.

\subsection{Zavádění tříd}

Všechny třídy jsou přeloženy do \classfile{} souborů. Ty mohou být následně zabaleny do JAR\nomenclature{JAR}{Java ARchive}, což je v~podstatě ZIP archív. JVM při startu vyhledá tzv. Main-Class a k~ní všechny závislé třídy a k~nim další závislé třídy v~tzv. \emph{classpath}. U~každé třídy se provede statická inicializace. Toto vyhledávání není omezeno pouze na úvodní spuštění JVM. Volání \method{Class.forName()}, \method{ClassLoader.loadClass()}, \emph{Reflection API} a \method{JNI\_FindClass} může vyvolat \emph{zavádění tříd}\footnote{V anj. \emph{class loading}} kdykoliv za běhu programu, pokud požadovaná třída není již nahrána\cite{gosling2013java}\cite{lindholm2013java}.

Další fází při \emph{zavádění tříd} je i verifikace \bytecode{}. Všechny překladače Java (\javac{}) vytvářejí validní \classfile{} soubory a typově bezpečný kód. Jenže JVM se nemůže spolehnout, že soubor, který nahrála je správný. Proto musí ověřit, že je vše v~pořádku -- ať již instrukce zadané v~\classfile{} souboru nebo typová bezpečnost.

Výše popsaný proces \emph{zavádění tříd} je velmi náročný na I/O operace a zásadním způsobem ovlivní výsledek měření, pokud se nepředejde tomuto zavádění během měření.

\subsection{JIT\label{sub:JIT}}
Tradiční překladače (např. C/\CC) generují z~vyššího programovacího jazyka strojově závislý kód. Tento kód má finální podobu a všechny možné optimalizace je zapotřebí udělat během překladu. Případně použít profilování výsledné binárky a znovu nechat překladač znovu přeložit kód s~využitím profilovacích dat. Těmto překladačům se říká také statické. Výsledný kód je optimalizován pro danou platformu.

Java používá překladač \javac{}, který z~vysoko úrovňového jazyka vytvoří \classfile{}, který obsahuje \bytecode{}. JVM tento \bytecode{} následně dynamicky za běhu překládá do strojově závislého kódu pomocí JIT.

\subsubsection{Jak funguje překladač}
Každý překladač má podobnou strukturu. Musí mít na vstupu modul pro převod zdrojového kódu do tzv. \emph{intermediate representation (IR)}\nomenclature{IR}{Intermediate Representation}.\footnote{Existují různé typy IR. Pro každou fázi překladu se dokonce může použít jiný IR.} IR je mezistupeň před \todo{Popsat co je IR} Všechny překladače dělají největší optimalizace právě na IR. Množina možných optimalizací může být velmi široká a je často omezena množstvím času nutném k~provedení dané optimalizace. Mezi jednoduché optimalizace patří zjednodušování logických výrazů, nahrazování proměnných konstantami a \emph{function inlining}. Složitější optimalizace jsou většinou spojeny se smyčkami -- loop unrolling, odstraňování kontroly rozsahu smyčky atd\ldots{}

Když jsou tyto optimalizace hotovy, další modul vezme danou IR a převede ji do strojové podoby. Zde nastávají další optimalizace v~podobě přiřazování hodnot do registrů procesoru, výběr vhodných instrukcí atd\ldots{}

\subsubsection{Kdy JIT překládá do strojového kódu\label{subsub:whenJIT}}
JIT nepřekládá každou instrukci v~\bytecode{} ihned do strojového kódu. Většina instrukcí je na začátku interpretována. Až v~okamžiku, kdy daná instrukce se stane \emph{hot}, JIT ji zařadí pro překlad. JVM totiž udržuje u~každé metody čítač volání. Pokud daná metoda je volána více krát, stane se \emph{hot} a tím se vyvolá i její překlad. Hranice překladu je ve výchozím nastavení 10000.\footnote{Parametr pro Oracle JVM, který ovlivňuje toto nastavení je \cmd{-XX:CompileThreshold=}} Zjednodušeně řečeno: aby došlo k~překladu libovolné metody do strojového kódu, musí být daná metoda volána aspoň 10000.

Níže jsou uvedeny optimalizace, které ovlivňují výkonnost kódu.

\begin{description}
\item[function inlining] Je technika vnořování těla kódu funkcí/metod do těla volané metody. Protože každá metoda třídy je v jazyce Java virtuální, tato optimalizace odstraňuje penalizaci za jejich volání. Ve výsledku vytváří velké bloky kódu, nad kterými se uplatňují další optimalizace. Vnořování nedochází u všech metod. Podmínkou je, aby metoda byla krátká, což znamená, aby měla velikost do 35 \bytecode s.\footnote{V Oracle JVM lze toto omezení upravit pomocí parametru \cmd{-XX:FreqInlineSize=}} Vnořování nemůže být vynuceno. Záleží na JIT. Není ani žádné doporučení pro kompilátor jako je tomu u \CC{} pomocí vyhrazeného slova \method{inline} u metody.\footnote{\method{inline} říká kompilátoru, že by mohl metodu vnořit, ale záleží na chytrosti kompilátoru, zda vnoření provede\cite{Stroustrup:1997:CPL:523265}.}

Tato technika má zásadní dopad na běh programu. Ve výsledku nutí programátora navrhnout třídy tak, aby byly tvořeny malými metodami, což má za následek i dobrou čitelnost kódu.

\item[dead code elimination] JIT je schopen při analýze běhu programu identifikovat části kódu, které nemají žádný vedlejší efekt, např. pokud se výsledek volání metody nepoužije v dalších krocích nebo. Pokud je měřící kód nesprávně navrhnut, může dojít k tomu, že díky této optimalizaci se některé části nevykonají a výsledky měření jsou nepoužitelné.

\item[loop unrolling] Slouží k rozbalení smyček jako je \method{for (...) ...}. Klasická optimalizace, která tělo smyčky \uv{zkopíruje} několikrát za sebou. Každá smyčka má inkrementální část a podmínku pro ukončení smyčky. Podmínka pro ukončení má vliv na \emph{branch prediction} v CPU.\footnote{Moderní CPU mají velmi sofistikované algoritmy na předpovídání větvení programu s předčítáním instrukcí do \emph{pipeline}. Pokud CPU špatně odhadne následující větev kódu, v drtivé většině případů musí \uv{zahodit} a znovu načíst instrukce do \emph{pipeline}. Tato operace je velmi drahá a zastaví na několik cyklů vykonávání instrukcí CPU.} Ve výsledku se daná podmínka nevyhodnocuje tak často.

\begin{figure}
\begin{lstlisting}[frame=single,language=Java,caption=Před loop unrolling]
for (int x = 0; x < 50; x++) {
  doSomethingWith(x);
}
\end{lstlisting}
\begin{lstlisting}[frame=single,language=Java,caption=Po loop unrolling]
for (int x = 0; x < 50; x+=5) {
  doSomethingWith(x);
  doSomethingWith(x+1);
  doSomethingWith(x+2);
  doSomethingWith(x+3);
  doSomethingWith(x+4);
}
\end{lstlisting}
\end{figure}
\end{description}

\subsection{Zahřátí JVM}

Pokud bychom začali měřit jednotlivé části kódu ihned po startu JVM, neměřili bychom výkonnost samotného kódu, ale i čas za jak dlouho JVM zavede jednotlivé \classfile soubory, za jak dlouho JIT přeloží a optimalizuje instrukce \bytecode{} do strojového kódu. Pravděpodobně by se i naměřené hodnoty pro stejné testované parametry lišily, protože by k~překladu docházelo v~průběhu nebo mezi jednotlivými měřeními. Proto je nutné udělat i tzv. \emph{zahřátí JVM}.\footnote{V anj. \emph{JVM warm-up}}

Zahřátí se provádí tak, že se zavolá měřený kód tolikrát, aby se stal \emph{hot}.\footnote{Viz \prettyref{subsub:whenJIT}} Po tomto zahřátí, by již měl být měřený kód optimalizován a převeden do strojového kódu a měření by nemělo být ovlivněno.

\subsection{GC během měření}
Jak bylo uvedeno v \prettyref{subsub:gctypes}, během úklidu paměti může dojít k zastavení aplikace.
Je otázka, jak tomuto zastavení přistupovat při měření.
V reálné aplikaci je toto běžné a záleží na typu aplikace, zda je zastavení celé aplikace na určitý časový okamžik problém nebo ho lze tolerovat.
Podle typu aplikace je tedy vhodné vybrat i správný \emph{garbage collector}.

V případě testování výkonnosti určitého algoritmu je zřejmě vhodné zabránit úklidu během měření, protože ve výsledném měření bude i započítán čas nutný pro úklid paměti.
Z aplikace je možné vynutit úklid pomocí voláni \method{System.gc()} a \uv{počkat}, dokud neproběhne úklid paměti.
V měřeních jsem tohoto volání využil, aby se opravdu měřil čas nutný k vykonání \emph{Range Query}.

\section{Metoda a výsledky měření}
\subsection{Metoda měření}
\MIndex má několik parametrů, které ovlivňují jeho chování, resp. výkonnost, v závislosti na velikosti a typu indexovaných dat. Parametry pro měření jsou následující:

Průběh testu je popsán níže.

\begin{enumerate}
\item Vygenerování parametrů pro testy
\item Načtení vstupních dat ze souboru a vytvoření vektorů
\item Výpočet maximální vzdálenosti mezi objekty mimo třídy \type{*MIndex}, aby se pro každé nové měření nemusela znovu počítat vzdálenost.
Každá třída \type{cz.rank.vsfs.mindex.MultiLevelMIndex} a \type{cz.rank.vsfs.mindex.DynamiclMIndex} má konstruktor, který má parametr pro překalkulovanou maximální vzdálenost.
\item Zahřátí JVM
\item Série opakujících se dotazů \emph{Range Query}.
\begin{enumerate}
\item Vytvoření pivotů
\item Vytvoření instance \type{\MIndex}
\item Přiřazení vektorů do instance \type{\MIndex}
\item Vytvoření \MIndex u voláním metody \method{MIndex.build()}
\item Spuštění časovače
\item Jednotlivé dotazy \emph{Range Query} voláním \method{MIndex.rangeQuery()}
\item Vypnutí časovače
\end{enumerate}

\end{enumerate}
\subsection{Prostředí}
Měření probíhalo v tomto prostředí:

\begin{table}[h]
\catcode`\-=12
\center
\begin{tabular}{|l  | l | c |}
\hline
\multirow{9}{*}{CPU} & \multicolumn{2}{|c|}{AMD Phenom\texttrademark II X4 905e Processor} \\ \cline{2-3}
& Architektura & 64bit \\ \cline{2-3}
& Počet jader & 4 \\ \cline{2-3}
& Počet vláken & 4 \\ \cline{2-3}
& Frekvence & 2.5Ghz \\ \cline{2-3}
&  \multirow{2}{*}{L1 cache} & 4 x 64 KB pro instrukce \\
& & 4 x 64 KB pro data \\ \cline{2-3}
& L2 cache & 4 x 512KB \\ \cline{2-3}
& L3 cache & 6MB \\ \cline{2-3}
\hline
\multirow{3}{*}{RAM} & Velikost & 12GB \\ \cline{2-3}
& Typ & DDR3 \\ \cline{2-3}
& Frekvence & 1333MHz \\ \cline{2-3}
\hline
\multirow{2}{*}{Operační systém} &  \multicolumn{2}{|c|}{Debian/GNU Linux 7.0}  \\
&  \multicolumn{2}{|c|}{\tiny 3.8-trunk-amd64 \#1 SMP Debian 3.8.3-1~experimental.1 x86\_64 GNU/Linux} \\ \cline{2-3}
\hline
\multirow{2}{*}{Java} & JDK & {\tiny Java(TM) SE Runtime Environment (build 1.7.0\_13-b20)} \\ \cline{2-3}
& JVM & {\tiny Java HotSpot(TM) 64-Bit Server VM (build 23.7-b01, mixed mode)} \\ \cline{2-3}
 \hline
\end{tabular}
\caption{Informace o stroji}
\end{table}

\subsection{Parametry měření}
\todo{Popsat všechny parametry}
\todo{Zminit se o limitu Integer.MAX\_VALUE pro pivotsCount=100 a leafObjects=10}
\subsection{Výsledky měření}
\todo{Grafy a tabulky s~výsledky}
\missingfigure{Graf s~range 0.15 a pro max level}
\section{Srovnání výkonu implementací v~{\protect \CC}, C\# a Java}
\subsection{Srovnání implementací}
\todo{Porovnat implementaci p. Kmnuníčka s~mojí}
\subsection{Srovnání výsledků měření}
\todo{Vybrat stejné parametru měření a porovnat je navzájem}